# AI文本转换工具 - 测试计划

> 底层服务功能验证

**测试日期**: 2025-01-04
**测试版本**: Phase 1 - 底层服务 (阶段0-3)
**测试页面**: http://localhost:3000/ai-test

---

## 📋 测试目标

验证已完成的8个底层服务文件功能正常,确保:
1. ✅ API Key加密存储安全可靠
2. ✅ 文件处理功能正确
3. ✅ JSON合并逻辑准确
4. ✅ AI服务调用成功
5. ✅ 提示词构建正确
6. ✅ 结果解析无误
7. ✅ 流式处理完整
8. ✅ 进度回调实时

---

## 🧪 测试环境准备

### 1. 启动开发服务器

```bash
pnpm dev
```

### 2. 访问测试页面

打开浏览器访问: http://localhost:3000/ai-test

### 3. 准备测试资源

- **API Key**: 准备一个有效的OpenAI或兼容API的密钥
- **测试文件**: 准备一个包含测试文本的.txt或.md文件
- **浏览器**: 推荐使用Chrome或Edge (支持Web Crypto API)

---

## 📝 测试用例

### 测试用例1: API配置管理

**测试区域**: API配置测试区

#### 测试1.1: 保存API配置

**操作步骤**:
1. 在"选择提供商"下拉框选择 "OpenAI"
2. 在"API Key"输入框输入测试密钥 (如: `sk-test123456...`)
3. 在"Base URL"输入框确认为 `https://api.openai.com/v1`
4. 在"模型"下拉框选择 "gpt-4o-mini"
5. 点击"保存配置"按钮

**预期结果**:
- ✅ 显示"配置保存成功"提示
- ✅ 打开浏览器DevTools > Application > Local Storage
- ✅ 应该看到 `dh_ai_config` 键,值为加密字符串(不是明文)
- ✅ 刷新页面后配置应该自动加载

**验证要点**:
- API Key是否被加密存储 (不应该是明文)
- localStorage中的数据格式正确

---

#### 测试1.2: 读取API配置

**操作步骤**:
1. 刷新页面 (F5)
2. 观察配置表单是否自动填充

**预期结果**:
- ✅ 表单字段自动填充之前保存的配置
- ✅ API Key显示为 `sk-***` (部分隐藏)
- ✅ 提供商、Base URL、模型都正确回显

**验证要点**:
- 加密数据能正确解密
- 页面刷新后配置不丢失

---

#### 测试1.3: 测试API连接

**操作步骤**:
1. 确保已保存有效的API配置
2. 点击"测试连接"按钮
3. 等待响应

**预期结果**:
- ✅ 如果API Key有效: 显示"✅ 连接成功"
- ✅ 如果API Key无效: 显示"❌ 连接失败: 401 Unauthorized"
- ✅ 如果网络错误: 显示"❌ 连接失败: 网络错误"

**验证要点**:
- API服务能正确调用外部接口
- 错误信息清晰明确

---

### 测试用例2: 文件处理功能

**测试区域**: 文件处理测试区

#### 测试2.1: 上传.txt文件

**操作步骤**:
1. 准备一个.txt文件,内容如下:
```
## 职业卡：剑客
- 简介：以剑术为生的战士
- 领域1：武技
- 领域2：防御
```
2. 点击"选择文件"按钮或拖拽文件到上传区
3. 选择准备好的.txt文件

**预期结果**:
- ✅ 显示文件名、大小、类型
- ✅ 显示"✅ 文件读取成功"
- ✅ 文本内容完整显示在预览区
- ✅ 字符数统计正确

**验证要点**:
- FileProcessor能正确提取.txt文件内容
- 中文字符无乱码

---

#### 测试2.2: 上传.md文件

**操作步骤**:
1. 准备一个.md文件 (内容同上)
2. 上传该文件

**预期结果**:
- ✅ 成功读取并显示内容
- ✅ Markdown格式保留

**验证要点**:
- 支持.md文件格式
- 内容提取正确

---

#### 测试2.3: 上传不支持的文件

**操作步骤**:
1. 尝试上传.pdf或.docx文件

**预期结果**:
- ❌ 显示"不支持的文件格式: pdf"错误提示
- ❌ 不执行后续处理

**验证要点**:
- 文件类型验证有效
- 错误提示清晰

---

### 测试用例3: JSON合并功能

**测试区域**: JSON合并测试区

#### 测试3.1: 合并空数据

**操作步骤**:
1. 点击"测试场景1: 合并空数据"按钮

**预期结果**:
- ✅ 显示合并结果
- ✅ 结果数据为空对象或初始值
- ✅ 无错误抛出

**验证要点**:
- 处理空数据不报错

---

#### 测试3.2: 合并相同ID的卡牌 (merge策略)

**操作步骤**:
1. 点击"测试场景2: 合并相同ID (merge策略)"按钮

**预期结果**:
- ✅ 显示合并结果
- ✅ 相同ID的卡牌被合并 (新值填充旧值的空字段)
- ✅ 总卡牌数正确 (去重后的数量)

**示例数据**:
```javascript
现有数据: { id: '1', 名称: '战士', 简介: '' }
新数据:   { id: '1', 名称: '战士', 简介: '近战专家' }
合并结果: { id: '1', 名称: '战士', 简介: '近战专家' }
```

**验证要点**:
- merge策略正确实现
- 字段级合并逻辑正确

---

#### 测试3.3: customFieldDefinitions去重

**操作步骤**:
1. 点击"测试场景3: customFieldDefinitions去重"按钮

**预期结果**:
- ✅ 重复的字段定义被去重
- ✅ 顺序保持 (先existing,后incoming)

**示例数据**:
```javascript
现有: { professions: ['战士', '法师'] }
新增: { professions: ['法师', '游侠'] }
结果: { professions: ['战士', '法师', '游侠'] }
```

**验证要点**:
- Set去重逻辑正确
- 数组顺序合理

---

### 测试用例4: AI服务调用

**测试区域**: AI服务测试区

#### 测试4.1: 生成简单内容

**操作步骤**:
1. 确保已配置有效的API Key
2. 在"测试文本"输入框输入:
```
## 职业卡：剑客
- 简介：以剑术为生的战士
- 领域1：武技
- 领域2：防御
- 起始生命：14
- 起始闪避：8
```
3. 点击"调用AI生成"按钮
4. 等待响应 (约5-10秒)

**预期结果**:
- ✅ 显示"调用中..."加载状态
- ✅ 成功返回JSON格式的响应
- ✅ 响应包含 `cards` 数组
- ✅ 响应包含 `metadata` 对象
- ✅ `metadata.processedUpTo` 为数字
- ✅ 显示识别到的卡牌数量

**验证要点**:
- AI服务能正常调用
- 返回格式符合 AIChunkResponse 接口
- JSON解析无错误

---

#### 测试4.2: Token估算

**操作步骤**:
1. 在"测试文本"输入框输入一段文本
2. 观察"预估Token"显示

**预期结果**:
- ✅ 显示估算的Token数量
- ✅ 中文约 2字符=1token
- ✅ 英文约 4字符=1token

**验证要点**:
- Token估算逻辑合理
- 计算结果不为负数

---

### 测试用例5: 提示词构建

**测试区域**: 提示词构建测试区

#### 测试5.1: 生成系统提示词

**操作步骤**:
1. 点击"生成系统提示词"按钮

**预期结果**:
- ✅ 显示完整的系统提示词
- ✅ 包含AI创作指南内容
- ✅ 格式清晰,可读性好

**验证要点**:
- AIPromptBuilder能读取AI创作指南
- 提示词结构完整

---

#### 测试5.2: 生成首次用户提示词

**操作步骤**:
1. 输入测试文本 (约500字符)
2. 点击"生成首次提示词"按钮

**预期结果**:
- ✅ 显示首次块的用户提示词
- ✅ 包含"【流式处理说明】"
- ✅ 包含"【输出格式】"
- ✅ 包含"【文本内容】"及位置信息
- ✅ 文本窗口正确嵌入

**验证要点**:
- 首次提示词包含完整指南
- 格式符合设计要求

---

#### 测试5.3: 生成后续提示词

**操作步骤**:
1. 点击"生成后续提示词"按钮

**预期结果**:
- ✅ 显示后续块的用户提示词
- ✅ 包含"【继续处理】"
- ✅ 包含上下文摘要 (已处理统计、已识别字段)
- ✅ 提示词比首次短 (Token优化)

**验证要点**:
- 后续提示词更精简
- 上下文信息正确提取

---

### 测试用例6: 结果解析

**测试区域**: 结果解析测试区

#### 测试6.1: 解析正常数据

**操作步骤**:
1. 点击"测试场景1: 解析正常数据"按钮

**预期结果**:
- ✅ 成功解析
- ✅ `success: true`
- ✅ 统计信息正确 (totalCards, cardsByType)
- ✅ 无错误,无警告

**验证要点**:
- ResultParser能正常解析数据
- 统计逻辑正确

---

#### 测试6.2: 提取AI警告

**操作步骤**:
1. 点击"测试场景2: 提取AI警告"按钮

**预期结果**:
- ✅ 成功提取 `_warnings` 字段
- ✅ 警告数组正确
- ✅ `_warnings` 字段从数据中移除 (清理临时字段)

**验证要点**:
- 警告提取逻辑正确
- 数据清理完整

---

#### 测试6.3: 验证错误数据

**操作步骤**:
1. 点击"测试场景3: 验证错误数据"按钮

**预期结果**:
- ✅ `success: false`
- ✅ `errors` 数组包含验证错误
- ✅ 错误信息清晰 (path + message)

**验证要点**:
- ValidationService集成正常
- 错误信息格式正确

---

### 测试用例7: 流式批量处理 (核心测试)

**测试区域**: 流式处理测试区

#### 测试7.1: 处理小文本 (<1000字符)

**操作步骤**:
1. 在"测试文本"输入框输入约800字符的文本 (1-2张卡牌)
2. 点击"开始处理"按钮
3. 观察进度显示

**预期结果**:
- ✅ 显示"parsing"阶段
- ✅ 进度条从0%到90%再到100%
- ✅ 显示当前块信息 (chunk 1/1)
- ✅ 实时更新统计 (已识别卡牌数)
- ✅ 最终进入"validating"阶段
- ✅ 完成后显示"completed"
- ✅ 最终数据包含识别的卡牌
- ✅ 处理时间合理 (约10-20秒)

**验证要点**:
- StreamingBatchProcessor完整执行
- 进度回调正常
- 数据合并正确

---

#### 测试7.2: 处理中等文本 (3000-5000字符)

**操作步骤**:
1. 输入约4000字符的文本 (包含5-8张卡牌)
2. 开始处理
3. 观察分块情况

**预期结果**:
- ✅ 文本被分为多个块 (预估2-3块)
- ✅ 每块处理后进度更新
- ✅ 显示 "chunk 1/3", "chunk 2/3", "chunk 3/3"
- ✅ 卡牌数量逐步累加
- ✅ 最终所有卡牌合并正确
- ✅ 无重复卡牌 (去重生效)

**验证要点**:
- 滑动窗口机制正常
- 多块数据合并无误
- 去重逻辑有效

---

#### 测试7.3: 进度回调验证

**操作步骤**:
1. 处理任意文本
2. 观察控制台日志 (F12 > Console)

**预期结果**:
- ✅ 控制台打印 "[StreamingBatchProcessor] 开始处理文本"
- ✅ 每块处理时打印 "[Chunk N] 开始处理..."
- ✅ 打印 "AI返回: X 张卡牌"
- ✅ 打印 "处理到: XXX"
- ✅ 打印 "合并后总卡牌数: X"
- ✅ 最终打印 "✅ 文本处理完成"

**验证要点**:
- 日志输出完整
- 处理流程清晰

---

#### 测试7.4: 错误处理

**操作步骤**:
1. 清除或使用无效的API Key
2. 尝试处理文本

**预期结果**:
- ✅ 显示API调用失败错误
- ✅ 错误信息清晰
- ✅ 不会死循环或崩溃
- ✅ 可以返回重试

**验证要点**:
- 错误捕获完整
- 用户体验友好

---

## 📊 测试报告模板

测试完成后,请填写以下报告:

### 测试概况

| 项目 | 结果 |
|------|------|
| 测试日期 | YYYY-MM-DD |
| 测试人员 | [您的名字] |
| 浏览器 | Chrome/Edge/Firefox [版本号] |
| Node版本 | v20.x.x |
| 测试用例总数 | 21个 |
| 通过数量 | X个 |
| 失败数量 | X个 |
| 阻塞问题 | X个 |

### 测试结果汇总

| 测试用例 | 状态 | 备注 |
|---------|------|------|
| 1.1 保存API配置 | ✅/❌ | |
| 1.2 读取API配置 | ✅/❌ | |
| 1.3 测试API连接 | ✅/❌ | |
| 2.1 上传.txt文件 | ✅/❌ | |
| 2.2 上传.md文件 | ✅/❌ | |
| 2.3 上传不支持的文件 | ✅/❌ | |
| 3.1 合并空数据 | ✅/❌ | |
| 3.2 合并相同ID (merge) | ✅/❌ | |
| 3.3 customFieldDefinitions去重 | ✅/❌ | |
| 4.1 生成简单内容 | ✅/❌ | |
| 4.2 Token估算 | ✅/❌ | |
| 5.1 生成系统提示词 | ✅/❌ | |
| 5.2 生成首次提示词 | ✅/❌ | |
| 5.3 生成后续提示词 | ✅/❌ | |
| 6.1 解析正常数据 | ✅/❌ | |
| 6.2 提取AI警告 | ✅/❌ | |
| 6.3 验证错误数据 | ✅/❌ | |
| 7.1 处理小文本 | ✅/❌ | |
| 7.2 处理中等文本 | ✅/❌ | |
| 7.3 进度回调验证 | ✅/❌ | |
| 7.4 错误处理 | ✅/❌ | |

### 发现的问题

| 问题ID | 严重程度 | 描述 | 复现步骤 | 预期结果 | 实际结果 |
|--------|---------|------|---------|---------|---------|
| BUG-001 | 高/中/低 | ... | ... | ... | ... |

### 测试结论

- [ ] 所有核心功能通过测试,可以继续UI层开发
- [ ] 存在非阻塞问题,可以继续开发并记录待修复
- [ ] 存在阻塞问题,需要先修复再继续

### 建议

[您的测试建议和改进意见]

---

## ✅ 测试通过标准

满足以下条件即可认为底层服务测试通过:

1. ✅ **API配置管理** (测试1.x) 至少80%通过
2. ✅ **文件处理** (测试2.x) 至少80%通过
3. ✅ **JSON合并** (测试3.x) 100%通过 (核心功能)
4. ✅ **AI服务调用** (测试4.1) 必须通过 (核心功能)
5. ✅ **提示词构建** (测试5.x) 至少80%通过
6. ✅ **结果解析** (测试6.x) 至少80%通过
7. ✅ **流式处理** (测试7.1, 7.2) 必须通过 (核心功能)

**最低要求**: 测试7.1 (处理小文本) 必须完全成功,这是整个系统的核心功能验证。

---

**祝测试顺利!** 🎯
