# 真实卡包图片系统设计

## 📋 目录

- [设计目标](#设计目标)
- [核心原则](#核心原则)
- [架构概览](#架构概览)
- [数据结构](#数据结构)
- [分流策略](#分流策略)
- [核心接口](#核心接口)
- [实现细节](#实现细节)
- [导入导出流程](#导入导出流程)
- [使用示例](#使用示例)

---

## 设计目标

### 问题背景

系统需要支持两种完全不同的图片管理场景：

1. **卡牌编辑器** - 用户正在创建/编辑的卡包
   - 单一编辑环境
   - 频繁的单卡修改
   - 需要实时预览

2. **真实卡包系统** - 已导入的完整卡包
   - 多批次管理
   - 批次级原子操作
   - **导入后不再修改**

### 设计目标

✅ **完全隔离** - 编辑器和真实卡包使用独立的表和接口
✅ **自动分流** - 根据卡牌类型自动选择正确的读取方式
✅ **批次原子** - 真实卡包的所有操作都是批次级事务
✅ **极简键设计** - 直接使用 `cardId`，无需批次前缀（cardId 已包含 packageName + author，全局唯一）

---

## 核心原则

### 1. 双表隔离

| 表名 | 用途 | 键格式 | 场景 |
|------|------|--------|------|
| `editorImages` | 编辑器图片 | `cardId` | 卡牌编辑器专用 |
| `images` | 真实卡包图片 | `cardId` | 已导入的卡包 |

### 2. 类型驱动分流

**判断依据**: `ExtendedStandardCard.batchId` 字段

```typescript
interface ExtendedStandardCard extends StandardCard {
  source?: CardSource;
  batchId?: string;      // ✅ 分流的关键字段
  batchName?: string;
}
```

**分流规则**:
- `batchId` **不存在** → 编辑器卡牌 → 读取 `editorImages` 表
- `batchId` **存在** → 真实卡包卡牌 → 读取 `images` 表

### 3. 职责分离

| 函数 | 职责 | 使用场景 |
|------|------|----------|
| `getImageUrlFromDB(cardId)` | 编辑器图片读取 | 仅限编辑器内部 |
| `store.getImageUrl(cardId)` | 真实卡包图片读取（带缓存） | 通用图片读取 |
| `getCardImageUrlAsync(card)` | 通用预览层 | 自动分流 |

### 4. cardId 全局唯一性

**cardId 格式**: `${packageName}-${author}-${typeCode}-${suffix}`

**示例**:
- 编辑器卡牌: `mypack-john-prof-warrior`
- 真实卡包: `official-core-criticalrole-prof-ranger`

**关键点**:
- ✅ cardId 包含了 packageName 和 author
- ✅ 不同卡包的卡牌 cardId 不会冲突
- ✅ 可以直接使用 cardId 作为 IndexedDB 键，无需 batchId 前缀

---

## 架构概览

```
┌─────────────────────────────────────────────────────────────┐
│                        通用预览层                              │
│                 getCardImageUrlAsync(card)                   │
│                                                               │
│                  判断: card.batchId?                          │
└────────────────────┬────────────────┬───────────────────────┘
                     │                │
           有 batchId│                │无 batchId
                     ↓                ↓
        ┌────────────────┐   ┌────────────────┐
        │   真实卡包分支   │   │   编辑器分支    │
        └────────────────┘   └────────────────┘
                 │                    │
                 ↓                    ↓
    ┌─────────────────────┐  ┌──────────────────┐
    │ store.getImageUrl() │  │ getImageUrlFromDB│
    │                     │  │                  │
    │ 1. 检查 editorImages│  │ 直接读取:        │
    │ 2. 读取 images 表   │  │ editorImages.get │
    │    (键 = cardId)    │  │      (cardId)    │
    │ 3. 缓存结果         │  │                  │
    └─────────────────────┘  └──────────────────┘
                 │                    │
                 ↓                    ↓
        ┌──────────────────────────────────┐
        │         IndexedDB                 │
        │  ┌──────────────┬───────────────┐│
        │  │ images       │ editorImages  ││
        │  │ 键: cardId   │ 键: cardId    ││
        │  └──────────────┴───────────────┘│
        └──────────────────────────────────┘
```

---

## 数据结构

### IndexedDB Schema

```typescript
Database: "card-images"

{
  // 真实卡包图片表
  images: {
    key: string,        // 主键: "cardId" (直接使用卡牌ID)
    blob: Blob,
    mimeType: string,
    size: number,
    createdAt: number
  },

  // 编辑器图片表
  editorImages: {
    key: string,        // 主键: "cardId"
    blob: Blob,
    mimeType: string,
    size: number,
    createdAt: number
  }

  // 注意: 不再需要 batchRegistry 表
  // 批次信息（包括图片ID列表）存储在 localStorage 中
}
```

### 批次元信息（localStorage）

```typescript
// 存储键: daggerheart_custom_cards_batch_{batchId}
interface BatchInfo {
  id: string;              // 批次ID
  name: string;            // 批次名称
  fileName: string;        // 原始文件名
  importTime: string;      // 导入时间
  version?: string;
  description?: string;
  author?: string;
  cardCount: number;       // 卡牌总数
  cardTypes: string[];     // 卡牌类型列表
  cardIds: string[];       // 所有卡牌ID列表
  imageCardIds: string[];  // ✅ 有图片的卡牌ID列表（用于删除）
  size: number;            // 数据大小
}
```

### 卡牌数据结构

```typescript
// 编辑器卡牌
{
  id: "pack-author-prof-warrior",
  name: "战士",
  imageUrl: "db://pack-author-prof-warrior",
  // 注意: 没有 batchId 字段
}

// 真实卡包卡牌
{
  id: "official-prof-ranger",
  name: "游侠",
  imageUrl: "db://official-prof-ranger",
  batchId: "official_core",          // ✅ 关键字段
  batchName: "Official Core Cards",
  source: "custom"
}
```

---

## 分流策略

### 判断逻辑

```typescript
function getImageSource(card: StandardCard): 'editor' | 'realBatch' | 'none' {
  const extendedCard = card as ExtendedStandardCard;

  if (!card.imageUrl?.startsWith('db://')) {
    return 'none'; // 不是 IndexedDB 图片
  }

  if (extendedCard.batchId) {
    return 'realBatch'; // 真实卡包图片
  }

  return 'editor'; // 编辑器图片
}
```

### 分流表

| 场景 | `card.batchId` | `card.imageUrl` | 读取函数 | 查询表 |
|------|---------------|----------------|---------|--------|
| 编辑器卡牌 | `undefined` | `db://cardId` | `getImageUrlFromDB(cardId)` | `editorImages` |
| 真实卡包卡牌 | `"official_core"` | `db://cardId` | `store.getImageUrl(cardId)` | `images` |
| 普通图片 | - | `/image/xxx.webp` | 直接使用路径 | - |

---

## 核心接口

### 1. 编辑器图片读取（独立）

**函数**: `getImageUrlFromDB(cardId: string)`
**位置**: `app/card-editor/utils/image-db-helpers.ts`
**用途**: 仅用于卡牌编辑器内部

```typescript
/**
 * 获取编辑器图片的临时 URL
 * 注意: 仅用于编辑器环境
 */
export async function getImageUrlFromDB(cardId: string): Promise<string | null> {
  try {
    const db = getCardImageDB();
    const record = await db.editorImages.get(cardId);

    if (record) {
      return URL.createObjectURL(record.blob);
    }

    return null;
  } catch (error) {
    console.error('[ImageDB] Failed to get image URL:', error);
    return null;
  }
}
```

### 2. 真实卡包图片读取（Store方法）

**函数**: `store.getImageUrl(cardId: string)`
**位置**: `card/stores/image-service-actions.ts`
**用途**: 通用图片读取（自动分流编辑器和真实卡包）

```typescript
/**
 * 获取图片URL（带缓存）
 * 自动处理编辑器图片和真实卡包图片
 *
 * @param cardId 卡牌ID
 * @returns Blob URL 或 null
 */
getImageUrl: async (cardId: string): Promise<string | null> => {
  const state = get();

  if (!state.imageService.initialized) {
    console.warn('[getImageUrl] Image service not initialized');
    return null;
  }

  const db = state.imageService.db!;

  try {
    // 1. 优先检查编辑器表（编辑中的卡牌）
    const editorRecord = await db.editorImages.get(cardId);
    if (editorRecord) {
      return URL.createObjectURL(editorRecord.blob);
    }

    // 2. 检查卡牌是否属于真实卡包
    const card = state.cards.get(cardId);
    if (!card?.batchId) {
      console.warn(`[getImageUrl] Card not found or missing batchId: ${cardId}`);
      return null;
    }

    // 3. 从真实卡包表读取（使用缓存）
    const { getCachedImageUrl } = await import('./image-service');

    return getCachedImageUrl(
      cardId,  // ✅ 直接使用 cardId 作为键
      state.imageCache,
      (updater) => set(state => ({
        imageCache: updater(state.imageCache)
      }))
    );

  } catch (error) {
    console.error(`[getImageUrl] Failed to get image for ${cardId}:`, error);
    return null;
  }
}
```

### 3. 通用预览层（自动分流）

**函数**: `getCardImageUrlAsync(card: StandardCard)`
**位置**: `lib/utils.ts`
**用途**: 所有预览组件使用

```typescript
/**
 * 异步获取卡牌图片URL（自动分流）
 * 根据 card.batchId 自动判断是编辑器图片还是真实卡包图片
 */
export async function getCardImageUrlAsync(
  card: StandardCard | undefined,
  isError: boolean = false
): Promise<string> {
  const basePath = getBasePath();

  if (isError || !card) {
    return `${basePath}/image/empty-card.webp`;
  }

  let imageUrl = card.imageUrl;

  // 尝试从 store 查找完整卡牌数据
  if (!imageUrl && card.id) {
    const store = useUnifiedCardStore.getState();
    if (store.initialized) {
      const foundCard = store.getCardById(card.id);
      if (foundCard?.imageUrl) {
        imageUrl = foundCard.imageUrl;
      }
    }
  }

  // 处理 db:// 前缀（IndexedDB 图片）
  if (imageUrl?.startsWith('db://')) {
    const cardId = imageUrl.substring(5); // 移除 "db://" 前缀

    try {
      // 类型转换检查 batchId
      const extendedCard = card as any;

      if (extendedCard.batchId) {
        // 真实卡包分支 - 使用 unified-card-store
        const store = useUnifiedCardStore.getState();
        const blobUrl = await store.getImageUrl(cardId);

        if (blobUrl) {
          return blobUrl;
        }

        console.warn(`[getCardImageUrlAsync] Real card image not found: ${cardId}`);
        return `${basePath}/image/empty-card.webp`;

      } else {
        // 编辑器分支 - 使用编辑器专用函数
        const { getImageUrlFromDB } = await import('@/app/card-editor/utils/image-db-helpers');
        const blobUrl = await getImageUrlFromDB(cardId);

        if (blobUrl) {
          return blobUrl;
        }

        console.warn(`[getCardImageUrlAsync] Editor image not found: ${cardId}`);
        return `${basePath}/image/empty-card.webp`;
      }

    } catch (error) {
      console.error(`[getCardImageUrlAsync] Failed to load image ${cardId}:`, error);
      return `${basePath}/image/empty-card.webp`;
    }
  }

  // 其他类型的 imageUrl（相对路径等）
  if (!imageUrl) {
    return `${basePath}/image/empty-card.webp`;
  }

  // ... 处理其他路径格式
}
```

---

## 实现细节

### 1. 批次级导入（原子事务）

**函数**: `importBatchImages(batchId, batchName, cards, images)`
**位置**: `card/stores/image-service/image-manager.ts`

```typescript
/**
 * 批次导入图片（原子事务）
 *
 * @param batchId 批次ID
 * @param batchName 批次名称
 * @param cards 卡牌数据数组
 * @param images 图片Map (key: cardId, value: Blob)
 * @returns 导入结果（包含 imageCardIds 列表）
 */
export async function importBatchImages(
  batchId: string,
  batchName: string,
  cards: ExtendedStandardCard[],
  images: Map<string, Blob>
): Promise<BatchImportResult> {
  const db = getCardImageDB();

  try {
    const result = await db.transaction(
      'rw',
      db.images,  // 只需要 images 表，不需要 batchRegistry
      async () => {
        const imageRecords: ImageRecord[] = [];
        const imageCardIds: string[] = [];  // ✅ 记录有图片的卡牌ID
        let totalSize = 0;
        const updatedCards: ExtendedStandardCard[] = [];

        // 准备图片记录
        for (const card of cards) {
          const blob = images.get(card.id);

          if (blob) {
            // ✅ 直接使用 cardId 作为键（无 batchId 前缀）
            const imageKey = card.id;

            imageRecords.push({
              key: imageKey,
              blob: blob,
              mimeType: blob.type || 'image/webp',
              size: blob.size,
              createdAt: Date.now()
            });

            imageCardIds.push(card.id);  // ✅ 记录卡牌ID
            totalSize += blob.size;

            // 更新卡牌的 imageUrl
            updatedCards.push({
              ...card,
              imageUrl: generateDbUrl(card.id)  // "db://cardId"
            });
          } else {
            updatedCards.push(card);
          }
        }

        // 批量写入图片到 IndexedDB
        await db.images.bulkPut(imageRecords);

        return {
          importedCount: imageRecords.length,
          totalSize: totalSize,
          updatedCards: updatedCards,
          imageCardIds: imageCardIds  // ✅ 返回图片ID列表
        };
      }
    );

    return {
      success: true,
      batchId: batchId,
      ...result
    };

  } catch (error) {
    console.error('[importBatchImages] Transaction failed:', error);
    return {
      success: false,
      batchId: batchId,
      importedCount: 0,
      totalSize: 0,
      updatedCards: cards,
      imageCardIds: [],  // ✅ 空列表
      errors: [error instanceof Error ? error.message : String(error)]
    };
  }
}
```

**关键变化**:
- ✅ 键格式从 `batchId/cardId` 改为 `cardId`
- ✅ 返回 `imageCardIds` 列表（用于后续删除）
- ✅ 不再需要 `batchRegistry` 表

### 2. 批次级删除

**函数**: `deleteBatchImages(imageCardIds: string[])`
**位置**: `card/stores/image-service/image-manager.ts`

```typescript
/**
 * 删除批次图片
 * 注意: imageCardIds 从批次元信息（localStorage）中获取
 *
 * @param imageCardIds 有图片的卡牌ID列表
 */
export async function deleteBatchImages(imageCardIds: string[]): Promise<void> {
  if (imageCardIds.length === 0) {
    console.log('[deleteBatchImages] No images to delete');
    return;
  }

  const db = getCardImageDB();

  try {
    // 直接批量删除图片
    await db.images.bulkDelete(imageCardIds);

    console.log(`[deleteBatchImages] Deleted ${imageCardIds.length} images`);

  } catch (error) {
    console.error('[deleteBatchImages] Failed:', error);
    throw error;
  }
}
```

**关键变化**:
- ✅ 参数从 `batchId` 改为 `imageCardIds` 列表
- ✅ 不再需要查询 `batchRegistry`
- ✅ 直接使用传入的 ID 列表删除
- ✅ 图片ID列表从 localStorage 的批次元信息中获取

---

## 导入导出流程

### ZIP文件格式规范

真实卡包使用ZIP格式进行分发，标准结构如下：

```
mypack.zip
├── cards.json          # 卡牌数据（ImportData格式）
├── card1.webp          # 图片文件（文件名 = cardId）
├── card2.png
├── card3.jpg
└── ...
```

**关键规则**:
- ✅ `cards.json` 必须存在（包含所有卡牌数据）
- ✅ 图片文件名 = `{cardId}.{ext}`（扩展名：webp/png/jpg/jpeg）
- ✅ cardId 必须与 `cards.json` 中的卡牌ID一致
- ✅ 图片可选（没有图片的卡牌不影响导入）

### 卡包导入流程

```typescript
/**
 * 完整导入流程
 *
 * 步骤:
 * 1. 用户选择ZIP文件
 * 2. 解析ZIP内容（cards.json + 图片）
 * 3. 导入卡牌数据到Store
 * 4. 导入图片到IndexedDB
 * 5. 保存批次元信息到localStorage
 */

import { importZipCardPack } from '@/card/importers/zip-importer';
import { useUnifiedCardStore } from '@/card/stores/unified-card-store';

async function handleZipImport(file: File) {
  // 步骤1: 解析ZIP文件
  const zipResult = await importZipCardPack(file, file.name);

  if (!zipResult.success || !zipResult.data) {
    console.error('ZIP解析失败:', zipResult.errors);
    return;
  }

  const { data: importData, images } = zipResult;

  // 步骤2: 导入卡牌数据
  const store = useUnifiedCardStore.getState();
  const importResult = await store.importCustomCards(
    importData,
    file.name
  );

  if (!importResult.success) {
    console.error('卡牌导入失败');
    return;
  }

  const { batchId } = importResult;

  // 步骤3: 导入图片（如果有）
  if (images && images.size > 0) {
    const imageResult = await store.importBatchImages(
      batchId,
      importData.name || '未命名批次',
      images
    );

    if (!imageResult.success) {
      console.error('图片导入失败:', imageResult.errors);
      // 注意: 卡牌已导入，只是图片失败
    } else {
      console.log(
        `✅ 导入成功: ${imageResult.importedCount}张图片, ` +
        `${(imageResult.totalSize / 1024).toFixed(2)}KB`
      );

      // 步骤4: 更新localStorage中的批次元信息
      // (store.importBatchImages会自动处理，这里仅作说明)
      // localStorage中会保存:
      // - imageCardIds: string[]  (有图片的卡牌ID列表)
    }
  }

  console.log(`✅ 卡包导入完成: ${importData.name}`);
}
```

**导入后的数据存储**:

```
IndexedDB (card-images)
├── images 表
│   ├── key: "pack1-author-prof-warrior"  → Blob
│   ├── key: "pack1-author-prof-ranger"   → Blob
│   └── ...

localStorage
├── daggerheart_custom_cards_index
│   └── ["batch_123", "batch_456", ...]
│
└── daggerheart_custom_cards_batch_batch_123
    └── {
          id: "batch_123",
          name: "My Pack",
          cardIds: ["pack1-author-prof-warrior", "pack1-author-prof-ranger", ...],
          imageCardIds: ["pack1-author-prof-warrior"],  // ✅ 有图片的卡牌
          ...
        }
```

### 卡包导出流程

```typescript
/**
 * 完整导出流程
 *
 * 步骤:
 * 1. 从Store获取批次数据
 * 2. 从IndexedDB读取图片
 * 3. 生成cards.json
 * 4. 打包ZIP文件
 * 5. 触发浏览器下载
 */

import { exportAndDownloadBatch } from '@/card/exporters/zip-exporter';

async function handleBatchExport(batchId: string) {
  // 一键导出并下载
  const result = await exportAndDownloadBatch(batchId);

  if (result.success) {
    console.log('✅ 导出成功');
  } else {
    console.error('导出失败:', result.errors);
  }
}
```

**详细导出步骤**:

```typescript
import JSZip from 'jszip';
import { useUnifiedCardStore } from '@/card/stores/unified-card-store';
import { getImage } from '@/card/stores/image-service';

async function exportBatchDetailed(batchId: string) {
  const store = useUnifiedCardStore.getState();
  const batch = store.batches.get(batchId);

  if (!batch) {
    throw new Error(`批次不存在: ${batchId}`);
  }

  // 步骤1: 准备卡牌数据
  const cards = batch.cardIds
    .map((id: string) => store.cards.get(id))
    .filter((card) => card !== undefined);

  // 步骤2: 生成ImportData格式的JSON
  const importData = {
    name: batch.name,
    version: batch.version,
    description: batch.description,
    author: batch.author,
    profession: cards.filter(c => c.type === 'profession'),
    ancestry: cards.filter(c => c.type === 'ancestry'),
    // ... 其他类型
  };

  // 步骤3: 创建ZIP
  const zip = new JSZip();
  zip.file('cards.json', JSON.stringify(importData, null, 2));

  // 步骤4: 添加图片
  for (const card of cards) {
    if (card.imageUrl?.startsWith('db://')) {
      const cardId = card.imageUrl.substring(5);

      // 从IndexedDB读取图片（使用cardId作为键）
      const blob = await getImage(cardId);

      if (blob) {
        const ext = blob.type === 'image/png' ? 'png' :
                   blob.type === 'image/jpeg' ? 'jpg' : 'webp';

        // 文件名 = cardId.ext
        zip.file(`${card.id}.${ext}`, blob);
      }
    }
  }

  // 步骤5: 生成ZIP文件
  const zipBlob = await zip.generateAsync({
    type: 'blob',
    compression: 'DEFLATE',
    compressionOptions: { level: 6 }
  });

  // 步骤6: 下载
  const url = URL.createObjectURL(zipBlob);
  const a = document.createElement('a');
  a.href = url;
  a.download = `${batch.name}-${Date.now()}.zip`;
  a.click();
  URL.revokeObjectURL(url);
}
```

### 完整数据流图

```
┌─────────────────────────────────────────────────────────────┐
│                        ZIP 导入流程                           │
└─────────────────────────────────────────────────────────────┘

  User selects ZIP file
         ↓
  ┌─────────────────┐
  │ zip-importer.ts │ - 解析ZIP
  │                 │ - 提取 cards.json
  │                 │ - 提取图片文件
  └────────┬────────┘
           ↓
  ┌─────────────────┐
  │ Store Actions   │ - importCustomCards()
  │                 │   (保存卡牌数据)
  │                 │
  │                 │ - importBatchImages()
  │                 │   (保存图片到IndexedDB)
  └────────┬────────┘
           ↓
  ┌───────────────────────────────────────┐
  │ 持久化存储                             │
  │                                       │
  │ IndexedDB (card-images)               │
  │ ├── images 表                         │
  │ │   ├── key: cardId → Blob            │
  │ │   └── ...                           │
  │                                       │
  │ localStorage                          │
  │ ├── batch index                       │
  │ └── batch_xxx                         │
  │     ├── cardIds                       │
  │     └── imageCardIds  ← 新增字段     │
  └───────────────────────────────────────┘


┌─────────────────────────────────────────────────────────────┐
│                        ZIP 导出流程                           │
└─────────────────────────────────────────────────────────────┘

  User clicks export
         ↓
  ┌─────────────────┐
  │ Store Actions   │ - 读取批次数据
  │                 │ - 读取卡牌列表
  └────────┬────────┘
           ↓
  ┌─────────────────┐
  │ Image Service   │ - getImage(cardId)
  │                 │ - 从 IndexedDB 读取图片
  └────────┬────────┘
           ↓
  ┌─────────────────┐
  │ zip-exporter.ts │ - 生成 cards.json
  │                 │ - 打包图片
  │                 │ - 创建ZIP文件
  └────────┬────────┘
           ↓
  Browser downloads ZIP file
```

### 关键设计点

#### 1. cardId 作为图片文件名

**为什么使用 cardId**:
- ✅ cardId 是全局唯一的（包含 packageName + author）
- ✅ 导入时可以直接匹配卡牌和图片
- ✅ 无需额外的映射关系

**示例**:
```
卡牌ID: "mypack-john-prof-warrior"
图片文件名: "mypack-john-prof-warrior.webp"
IndexedDB键: "mypack-john-prof-warrior"
```

#### 2. imageCardIds 列表

**用途**: 删除批次时快速定位需要删除的图片

**工作流程**:
1. 导入时记录: `importBatchImages()` 返回 `imageCardIds`
2. 保存到localStorage: 批次元信息中
3. 删除时使用: 从localStorage读取，传递给 `deleteBatchImages(imageCardIds)`

#### 3. 原子性保证

**导入**:
- 使用 Dexie 事务确保图片批量写入的原子性
- 如果部分失败，整个批次回滚

**导出**:
- 图片读取失败不中断流程
- 记录错误但继续打包其他图片

---

## 使用示例

### 场景1: 编辑器上传图片

```typescript
// 卡牌编辑器内部
async function uploadImage(cardId: string, file: File) {
  const db = getCardImageDB();
  const blob = new Blob([await file.arrayBuffer()], { type: file.type });

  // 直接存入编辑器表
  await db.editorImages.put({
    key: cardId,
    blob: blob,
    mimeType: file.type,
    size: file.size,
    createdAt: Date.now()
  });

  // 更新卡牌数据
  card.imageUrl = `db://${cardId}`;
}
```

### 场景2: 导入真实卡包

```typescript
// 卡包管理器导入
const result = await store.importBatchImages(
  'official_core',           // batchId
  'Official Core Cards',     // batchName
  images
);

// 导入成功后:
if (result.success) {
  // 1. 所有卡牌:
  //    - card.batchId = 'official_core'
  //    - card.imageUrl = 'db://cardId'
  //    - 图片存储键 = 'cardId' (直接使用卡牌ID)

  // 2. 保存图片ID列表到 localStorage
  const batchInfo = store.batches.get('official_core');
  const updatedBatchInfo = {
    ...batchInfo,
    imageCardIds: result.imageCardIds  // ['card1', 'card2', ...]
  };

  localStorage.setItem(
    'daggerheart_custom_cards_batch_official_core',
    JSON.stringify(updatedBatchInfo)
  );
}
```

### 场景3: 预览卡牌（自动分流）

```typescript
// 任何预览组件
function CardPreview({ card }: { card: StandardCard }) {
  const [imageUrl, setImageUrl] = useState<string>('');

  useEffect(() => {
    async function loadImage() {
      // 自动判断是编辑器还是真实卡包
      const url = await getCardImageUrlAsync(card);
      setImageUrl(url);
    }

    loadImage();
  }, [card]);

  return <img src={imageUrl} alt={card.name} />;
}
```

### 场景4: 删除卡包

```typescript
// 批次级删除
async function deleteBatch(batchId: string) {
  // 1. 从 localStorage 读取批次元信息
  const batchInfo = JSON.parse(
    localStorage.getItem(`daggerheart_custom_cards_batch_${batchId}`) || '{}'
  );

  if (!batchInfo.imageCardIds || batchInfo.imageCardIds.length === 0) {
    console.log('[deleteBatch] No images to delete');
    return;
  }

  // 2. 删除 IndexedDB 中的图片
  await store.deleteBatchImages(batchInfo.imageCardIds);

  // 3. 清理缓存
  store.clearBatchImageCache(batchId);

  // 4. 删除批次元信息
  localStorage.removeItem(`daggerheart_custom_cards_batch_${batchId}`);
}
```

**关键点**:
- ✅ `imageCardIds` 从 localStorage 的批次元信息获取
- ✅ 直接传递 ID 列表，无需查询 `batchRegistry`
- ✅ 删除顺序: IndexedDB → 缓存 → localStorage

---

## 设计优势

### 1. 完全隔离

| 特性 | 编辑器 | 真实卡包 |
|------|--------|---------|
| 表 | `editorImages` | `images` |
| 键格式 | `cardId` | `cardId` |
| 读取函数 | `getImageUrlFromDB()` | `store.getImageUrl()` |
| 缓存 | 无需缓存 | 带 LRU 缓存 |
| 批次管理 | 不需要 | localStorage 元信息 |

### 2. 自动分流

- ✅ 根据 `card.batchId` 自动判断类型
- ✅ 无需手动指定读取方式
- ✅ 预览组件统一使用 `getCardImageUrlAsync()`

### 3. 类型安全

```typescript
// 真实卡包必须有 batchId
if (!card.batchId) {
  console.warn('编辑器卡牌不应调用 store.getImageUrl()');
  return null;
}
```

### 4. 原子操作

- ✅ 批次导入：要么全部成功，要么全部回滚
- ✅ 批次删除：一次性删除所有相关图片
- ✅ 无孤儿图片：通过 localStorage 元信息追踪

### 5. 简化架构

- ✅ 无需 `batchId` 前缀：cardId 自带全局唯一性（包含 packageName + author）
- ✅ 无需 `batchRegistry` 表：元信息存储在 localStorage
- ✅ 删除操作简化：直接使用 ID 列表，无需查询

---

## 注意事项

### ⚠️ 常见错误

**错误1: 编辑器卡牌调用真实卡包接口**
```typescript
// ❌ 错误
const editorCard = { id: 'test', imageUrl: 'db://test' }; // 无 batchId
await store.getImageUrl('test');  // 会报警告并返回 null

// ✅ 正确
await getImageUrlFromDB('test');
```

**错误2: 使用 `batchId` 作为键前缀**
```typescript
// ❌ 错误: 过去的设计（已废弃）
const key = generateImageKey(card.batchId, cardId);  // "batchId/cardId"

// ✅ 正确: 当前简化设计
const key = cardId;  // 直接使用 cardId（已包含全局唯一性）
```

**错误3: 混用两种读取方式**
```typescript
// ❌ 错误: 不要尝试从两个表查找
const editorImage = await db.editorImages.get(cardId);
if (!editorImage) {
  const realImage = await db.images.get(cardId);  // 没有 batchId 判断！
}

// ✅ 正确: 根据 batchId 判断使用哪个表
if (card.batchId) {
  // 真实卡包
  const realImage = await db.images.get(cardId);
} else {
  // 编辑器
  const editorImage = await db.editorImages.get(cardId);
}
```

### 📝 最佳实践

1. **编辑器代码**: 始终使用 `getImageUrlFromDB(cardId)`
2. **真实卡包代码**: 始终使用 `store.getImageUrl(cardId)`
3. **通用预览代码**: 使用 `getCardImageUrlAsync(card)` 自动分流
4. **键格式**: 真实卡包和编辑器都直接使用 `cardId` 作为键
5. **批次删除**: 从 localStorage 批次元信息获取 `imageCardIds`，直接传递给删除函数

---

## 相关文件

- `card/stores/image-service/database.ts` - 数据库定义
- `card/stores/image-service/image-manager.ts` - 批次级操作
- `card/stores/image-service-actions.ts` - Store actions
- `app/card-editor/utils/image-db-helpers.ts` - 编辑器帮助函数
- `lib/utils.ts` - 通用预览层
- `docs/卡牌图片IndexedDB存储架构.md` - 编辑器架构文档

---

## 更新日志

- **2025-01-02** - 初始版本
  - 定义编辑器和真实卡包的完全分离架构
  - 基于 `batchId` 的自动分流策略
  - 批次级原子操作设计
- **2025-01-02** - 简化架构更新
  - 移除 `batchId` 键前缀，直接使用 `cardId`（利用 cardId 的全局唯一性）
  - 移除 `batchRegistry` 表，使用 localStorage 批次元信息
  - 简化删除操作：直接使用 `imageCardIds` 列表
  - 更新所有代码示例和最佳实践
